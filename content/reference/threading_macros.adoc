Clojure programs often contain nested function applications. Code can easily
become harder to read as the level of nesting grows. Threading macros, also
known as arrow macros, are a family of language features intended to improve the
readability of nested function calls.

[[the-thread-first-macro]]
The "thread-first" macro
~~~~~~~~~~~~~~~~~~~~~~~~

Idiomatic Clojure uses pure functions that transform input data into a desired
output format. Consider a function that applies two transformation to a map:

------------------------------------------
(defn transform [a-map]
   (update (assoc a-map :color :red) :age inc))
------------------------------------------

`tranform` is an instance of a common pattern: it takes a value and transforms
it a number of times, with each step in the pipeline taking the result of the
previous step as its input. It is often possible to improve code of this shape
by rewriing it to use the thread-first macro:

---------------------------
(defn transform* [a-map]
   (-> a-map
      (assoc :color :red)
      (update :age inc))
---------------------------

`+++->+++` takes an initial value, its first argument, and "threads" it through
one or more expressions. Note that "threading" in this context refers to passing
a value through forms, which is unrelated to the concept of a thread as a
concurrency primitive.

Starting with the first form, the macro inserts the given value as its first
argument. When this is repeated at each subsequent step, the result of the
previous computation is inserted. What looks like a function call with two
arguments is in fact a call with three arguments, as the threaded value is
inserted just after the function name. It may be helpful to mark the insertion
point with three commas:

-------------------------------
(defn transform* [a-map]
   (-> a-map
      (assoc ,,, :color :red)
      (update ,,, :age inc))
-------------------------------

Though not often seen in the wild, this visual aid is valid Clojure syntax,
commas being considered whitespace by Clojure’s parser.

Semantically `transform` is equivalent to `transform*`: the macro expands
at compile time into the original code. The value of the macro call is the result of the
last computation, the call to `update`. But to a human programmer, the
re-written function looks different. It reads more like an informal
description of the algorithm: „Take a thing, increase its age, change
its color to red“. Of course, as we’re talking about immutable values,
the value is not actually mutated in place. Instead, the function
returns a new value with updated attributes.

A pipeline of nested function calls will have as many closing
parentheses as there are steps in the pipeline, whereas the threading
macro will end with only two. So the threading macro is one way to keep
parentheses under control. Indeed, introducing `+++->+++` is a common
refactoring, and one sign that a threading macro might improve the code
is that three or more closing parentheses pile up at the end of a
function.

[[insertion-point]]
Adjusting the insertion point
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `+++->+++` macro follows a purely syntactic transformation rule: for each
expression, insert the threaded value between the function name and the
first argument. Note that the threading expressions are function calls
of the form `(f arg1 arg2 …)`. As a shorthand, a bare symbol or keyword
without parentheses is interpreted as a simple
invocation with a single argument. This allows for a succinct chain of
unary functions:

------------------------------------------------------
(-> a-map :color name clojure.string/upper-case)

;; equivalent to

(-> a-map (:color) (name) (clojure.string/upper-case))
------------------------------------------------------

However, `+++->+++` is not universally applicable, as we do not necessarily
always want to insert the threaded argument in initial position.
Consider a function that computes the sum of the squares of all even
positive integers up to (excluding) 10:

-------------------------------------------------------------
(defn calculate []
   (reduce + (map (fn [x] (* x x)) (filter odd? (range 10))))
-------------------------------------------------------------

Like `transform`, `calculate` is a pipeline of transformations, but
unlike the former the threaded value appears, in each function call, in
the final position in the argument list. Instead of the single arrow,
then, we need to use the double arrow:

----------------------------------
(defn calculate* []
   (->> (range 10)
        (filter odd? ,,,)
        (map (fn [x] (* x x)) ,,,)
        (reduce + ,,,)))
----------------------------------

Again, though they are usually omitted in practice, we’re adding three commas to
mark the place where the argument will be inserted. As you can see, in forms
threaded with `+++->>+++` the threaded value is inserted at the end rather than
at the beginning of the argument list.

Both thread-first and thread-last are in common use for pipelines. Which one is
appropriate depends on the signature of the transformation functions. Ultimately
you'll need to consult the documentation, but there are a few rules of thumb:

* By convention, core functions that operate on sequential collections expect
the collection as their last argument. Accordingly, pipelines containing `map`,
`filter`, `remove`, `reduce` or `into` usually call for the `+++->>+++` macro.

* Core functions that operate on associative data structures, on the other hand,
expect the value they work with as their first argument. These include `assoc`,
`update`, `dissoc`, `get` and their `-in` variants. Pipelines that modify maps
usually call for the `+++->+++` macro.

* When calling methods through Java inter-op, the Java object is passed as the
first argument. In these cases, `+++->+++` is useful. For example, to check a
string for a prefix, you could use:

+
----------------------------------
(-> a-string clojure.string/lower-case (.startsWith "prefix"))
----------------------------------

+
Note, however, that there are also more specialized macros  `..` and `doto` for Java inter-op.

Finally, there are cases where neither `+++->+++` nor `+++->>+++` are
applicable. A pipeline may consist of functions calls with varying insertion
points. In these cases, you'll need to use the more flexible alternative,
`+++as->+++`. `+++as->+++` expects two fixed arguments and a variable number of
expressions. As with `+++->+++`, the first argument is a value to be threaded
through the following forms. The second argument is the name of a binding. The
threaded value will be available in each of the subsequent forms under that
name.

----------------------------------
(as-> [:foo :bar] v
  (map name v)
  (first v)
  (.substring v 1)) ;; => "oo"
----------------------------------

[[specialized-threading-macros]]
Specialized threading macros
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

As one of Clojure's more specialized threading macros, `+++some->+++` and
its cognate `+++some->>+++` are used most commonly when intefacing with Java
methods. `+++some->+++` works like `+++->+++` in that it threads a value through
a number of expressions. It differs from it in that it short-circuits the
pipeline if an expression evaluates as `nil` at any point in the chain. One
common problem with arrow macros in the context of Java inter-op is that Java
methods do not expect to be passed `nil` (or `null`). You can avoid
`NullPointerExceptions` in these cases by adding explict guards:

----------------------------------
(let [counter (:counter a-map)]
  (when counter
    (inc (Long/parseLong counter)))
----------------------------------

`+++some->+++` achieves the same effect more succinctly:

----------------------------------
(some-> a-map :foo Long/parseLong inc)
----------------------------------

If `a-map` lacks the key `:foo`, the entire expression will evaluate as `nil`
rather than raising an exception. In fact this behavior is so useful that it is
common to see `+++some->+++` used without any threading:

----------------------------------
(some-> (compute) Long/parseLong)

;; equivalent to

(when-let [a-str (compute)]
  (Long/parseLong a-str))
----------------------------------

Like `+++->+++`, `+++cond->+++` takes an initial value, but unlike the former it
requires an even number of extra arguments. This argument list is interpreted as
a series of `test, expr` pairs. `cond->` threads a value through each
expression. However any expression is skipped if the associated test fails. For
each pair, `test` is evaluated. If the result is truthy, the expression is
evaluated with the previous value; otherwise evaluation proceeds with the next
`test, expr` pair. Note that unlike `some->` or `cond`, `cond->` never
short-circuits evaluation, even if a test evaluates as `false` or `nil`:

----------------------------------
(defn describe-number [n]
  (cond-> []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3) ;; => ["even" "positive"]
(describe-number 5) ;; => ["odd" "positive"]
----------------------------------

`+++cond->>+++` is similar but threads the argument as the last argument in each
form.

[[todo]]
Todo
~~~~

* add links to clojure.org
* clean up language
* actually try out code examples
