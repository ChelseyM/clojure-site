Clojure programs often contain nested function applications. Code can easily
become harder to read as the level of nesting grows. Threading macros, also
known as arrow macros, are a family of language features intended to improve the
readability of nested function calls.

[[the-thread-first-macro]]
The "thread-first" macro
~~~~~~~~~~~~~~~~~~~~~~~~

Idiomatic Clojure uses pure functions that transform input data into a desired
output format. Consider a function that applies two transformation to a map:

------------------------------------------
(defn transform [a-map]
   (update (assoc a-map :color :red) :age inc))
------------------------------------------

`tranform` is an instance of a common pattern: it takes a value and transforms
it a number of times, with each step in the pipeline taking the result of the
previous step as its input. It is often possible to improve code of this shape
by rewriing it to use the thread-first macro:

---------------------------
(defn transform* [a-map]
   (-> a-map
      (assoc :color :red)
      (update :age inc))
---------------------------

`+++->+++` takes an initial value, its first argument, and "threads" it through
one or more expressions. Note that "threading" in this context refers to passing
a value through forms, which is unrelated to the concept of a thread as a
concurrency primitive.

Starting with the first form, the macro inserts the given value as its first
argument. When this is repeated at each subsequent step, the result of the
previous computation is inserted. What looks like a function call with two
arguments is in fact a call with three arguments, as the threaded value is
inserted just after the function name. It may be helpful to mark the insertion
point with three commas:

-------------------------------
(defn transform* [a-map]
   (-> a-map
      (assoc ,,, :color :red)
      (update ,,, :age inc))
-------------------------------

Though not often seen in the wild, this visual aid is valid Clojure syntax,
commas being considered whitespace by Clojure’s parser.

Semantically `transform` is equivalent to `transform*`: the macro expands
at compile time into the original code. The value of the macro call is the result of the
last computation, the call to `update`. But to a human programmer, the
re-written function looks different. It reads more like an informal
description of the algorithm: „Take a thing, increase its age, change
its color to red“. Of course, as we’re talking about immutable values,
the value is not actually mutated in place. Instead, the function
returns a new value with updated attributes.

A pipeline of nested function calls will have as many closing
parentheses as there are steps in the pipeline, whereas the threading
macro will end with only two. So the threading macro is one way to keep
parentheses under control. Indeed, introducing `+++->+++` is a common
refactoring, and one sign that a threading macro might improve the code
is that three or more closing parentheses pile up at the end of a
function.

[[insertion-point]]
Adjusting the insertion point
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `+++->+++` macro follows a purely syntactic transformation rule: for each
expression, insert the threaded value between the function name and the
first argument. Note that the threading expressions are function calls
of the form `(f arg1 arg2 …)`. As a shorthand, a bare symbol or keyword
without parentheses is interpreted as a simple
invocation with a single argument. This allows for a succinct chain of
unary functions:

------------------------------------------------------
(-> a-map :color name clojure.string/upper-case)

;; equivalent to

(-> a-map (:color) (name) (clojure.string/upper-case))
------------------------------------------------------

However, `+++->+++` is not universally applicable, as we do not necessarily
always want to insert the threaded argument in initial position.
Consider a function that computes the sum of the squares of all even
positive integers up to (excluding) 10:

-------------------------------------------------------------
(defn calculate []
   (reduce + (map (fn [x] (* x x)) (filter odd? (range 10))))
-------------------------------------------------------------

Like `transform`, `calculate` is a pipeline of transformations, but
unlike the former the threaded value appears, in each function call, in
the final position in the argument list. Instead of the single arrow,
then, we need to use the double arrow:

----------------------------------
(defn calculate* []
   (->> (range 10)
        (filter odd? ,,,)
        (map (fn [x] (* x x)) ,,,)
        (reduce + ,,,)))
----------------------------------

Again, though this is not usually done, we’re using a triple comma to
mark the place where the argument will be inserted. Unlike with `+++->+++`,
forms threaded with `+++->>+++` see the threaded value inserted at the end of
their argument list.

Both thread-first and thread-last are in common use for pipelines. Which one is
appropriate depends on the signature of the transformation functions. Ultimately
you'll need to consult the documentation, but there are a few rules of thumb:

* By convention, core functions that operate on sequential collections expect
the collection as their last argument. Accordingly, pipelines containing `map`,
`filter`, `remove`, `reduce` or `into` usually call for the `+++->>+++` macro.

* Core functions that operate on associative data structures, on the other hand,
expect the value they work with as their first argument. These include `assoc`,
`update`, `dissoc`, `get` and their `-in` variants. Pipelines that modify
maps usually call for the `+++->+++` macro.

* When calling methods through Java inter-op, the Java object is passed as the first argument.
In these cases, `+++->+++` is useful. For example, to check a string for a prefix, you could
use:

+
----------------------------------
(-> string-to-check clojure.string/lower-case (.startsWith "prefix"))
----------------------------------

+
Note, however, that there are also more specialized macros  `..` and `doto` for Java inter-op.

Finally, there are cases where neither `+++->+++` nor `+++->>+++` are applicable. A pipeline may consist
of functions calls with varying insertion points. In these
cases, you'll need to use the more flexible alternative, `+++as->+++`.
`+++as->+++` expects two fixed arguments and a variable number of expressions. As with `+++->+++`,
the first argument is a value to be threaded through the following forms.
The second argument is the name of a binding. The threaded value will be available
in each of the subsequent forms under that name.

----------------------------------
(as-> [:foo :bar] v
  (map name v)
  (first v)
  (.substring v 1)) ;; => "oo"
----------------------------------

[[special-macros]]
Special threading macros
~~~~~~~~~~~~~~~~~~~~~~~~~

Clojure core also comes with a number of specialized threading macros.  `+++some->+++`
and its cognate `+++some->>+++` are often useful when intefacing with Java methods.
`+++some->+++` works like `+++->+++` in that it
threads a value through a number of exceptions. It differs from it in that it short-circuits
the pipeline if the value becomes `nil` at any point in the chain. One common
problem with arrow macros in the context of Java inter-op is that Java methods do
not expect to be passed `nil` (or `null`). You can avoid `NullPointerExceptions` in these cases
by adding explict guards:

----------------------------------
(let [counter (:counter a-map)]
  (when counter
    (inc (Long/parseLong counter)))
----------------------------------

Using `+++some->+++`, we can achieve the same effect more succinctly:

----------------------------------
(some-> a-map :counter Long/parseLong inc)
----------------------------------

If `a-map` does not have a key `:counter`, the `+++some->+++` expression will
return `nil`, rather than raising an exception. In fact this behavior is so
useful that it is common to see `+++some->+++` used with a single form:

----------------------------------
(some-> (compute) Long/parseLong)

;; equivalent to

(when-let [a-str (compute)]
  (Long/parseLong a-str))
----------------------------------

Like `+++->+++`, `+++cond->+++` takes an initial value, but unlike the former
it requires an even number of extra arguments. This argument list is interpreted as
a series of `test, expr` pairs. `cond->` threads a value through each expression, but
only if the associated test is true.  For each pair, `test` is evaluated. If the result
is truthy, the expression is evaluated with the previous value. Otherwise evaluation
proceeds with the next `test, expr` pair. Note that unlike `cond` or `some->`, `cond->`
does not short-circuit evaluation if a condition is `false` or `nil`.

----------------------------------
(defn describe-number [n]
  (cond-> []
    (odd? n) (conj "odd")
    (even? n) (conj "even")
    (zero? n) (conj "zero")
    (pos? n) (conj "positive")))

(describe-number 3) ;; => ["even" "positive"]
(describe-number 5) ;; => ["odd" "positive"]
----------------------------------

`+++cond->>+++` works the same but threads the argument as the last argument in each form.

[[todo]]
Todo
~~~~

* add links to clojure.org
* clean up language
* actually try out code examples
